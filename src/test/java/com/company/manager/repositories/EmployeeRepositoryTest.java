package com.company.manager.repositories;

import java.util.Date;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.AnnotationConfigContextLoader;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.transaction.annotation.Transactional;

import com.company.manager.configuration.TestConfig;
import com.company.manager.configuration.TestJPAConfiguration;
import com.company.manager.controllers.params.addressable.employee.EmployeeSearchParams;
import com.company.manager.controllers.params.addressable.employee.EmployeeSearchParams.EmployeeOrder;
import com.company.manager.models.Employee;
import com.company.manager.models.Office;
import com.company.manager.utils.RandomGenerator;
import com.company.manager.utils.RandomModelCreator;
import com.google.common.collect.Lists;

@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration(classes = {TestConfig.class, TestJPAConfiguration.class},
	loader=AnnotationConfigContextLoader.class)
@Transactional
public class EmployeeRepositoryTest {
	@Autowired
	private EmployeeRepository employeeRepository;
	@Autowired
	private OfficeRepository officeRepository;
	@Autowired
	private TestingRepository testingRepository;
	private Office office;
	
	@Before
	public void setUp(){
		office = RandomModelCreator.randomEntity(Office.class);
		office.setId(null);
		office.setEmployees(Lists.newArrayList());
		office.setClosed(null);
		officeRepository.persist(office);
	}
	
	@After
	public void tearDown(){
		//clean the database after test run
		testingRepository.wipeTablesData();
	}
	
	
	@Test
	public void testRetrieveAllEmployees() {
		List<Employee> randomEmployees = RandomModelCreator.randomEntities(Employee.class, 10);
		for(Employee randomEmployee: randomEmployees){
			randomEmployee.setId(null);
			randomEmployee.setOffice(this.office);
			randomEmployee.setWorkingSince(new Date());
			employeeRepository.persist(randomEmployee);
		}
		EmployeeSearchParams params = new EmployeeSearchParams();
		params.setFetchOffice(true);
		List<Employee> allEmployees = employeeRepository.search(params);
		Assert.assertEquals("Should return all the employees", 10, allEmployees.size());
	}
	
	@Test
	public void testIdAutogeneration(){
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Brian Griffin");
		newEmployee.setPhone("542-1235");
		newEmployee.setOffice(this.office);
		newEmployee.setWorkingSince(new Date());
		employeeRepository.persist(newEmployee);
		Assert.assertNotNull("When persisting an object, and Id should be autogenerated by the database", newEmployee.getId());
	}
	
	@Test
	public void testSearch() {
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Brian Griffin");
		newEmployee.setPhone("123-4567");
		newEmployee.setOffice(this.office);
		newEmployee.setWorkingSince(new Date());
		employeeRepository.persist(newEmployee);
		EmployeeSearchParams params = new EmployeeSearchParams();
		params.setEmail("bri");
		List<Employee> allEmployees = employeeRepository.search(params);
		Assert.assertEquals("When searching by email, like pattern should be applied", 1, allEmployees.size());
		Assert.assertEquals(newEmployee.getEmail(), allEmployees.get(0).getEmail());
		Assert.assertEquals(newEmployee.getEmail(), allEmployees.get(0).getEmail());
		Assert.assertEquals(newEmployee.getName(), allEmployees.get(0).getName());
		Assert.assertEquals(newEmployee.getPhone(), allEmployees.get(0).getPhone());
		Assert.assertEquals(newEmployee.getWorkingSince(), allEmployees.get(0).getWorkingSince());
		Assert.assertEquals(newEmployee.getOffice().getId(), allEmployees.get(0).getOffice().getId());
		params.setEmail(null);
		params.setName("brian");
		allEmployees = employeeRepository.search(params);
		Assert.assertEquals("Search should be case insensitive", 1, allEmployees.size());
		Assert.assertEquals(newEmployee.getEmail(), allEmployees.get(0).getEmail());
		Assert.assertEquals(newEmployee.getEmail(), allEmployees.get(0).getEmail());
		Assert.assertEquals(newEmployee.getName(), allEmployees.get(0).getName());
		Assert.assertEquals(newEmployee.getPhone(), allEmployees.get(0).getPhone());
		Assert.assertEquals(newEmployee.getWorkingSince(), allEmployees.get(0).getWorkingSince());
		Assert.assertEquals(newEmployee.getOffice().getId(), allEmployees.get(0).getOffice().getId());
		params.setEmail("bro");
		params.setName(null);
		allEmployees = employeeRepository.search(params);
		Assert.assertEquals("No match should be found", 0, allEmployees.size());
		params.setEmail("bri");
		params.setName("wrong");
		allEmployees = employeeRepository.search(params);
		Assert.assertEquals("No match should be found", 0, allEmployees.size());
		params = new EmployeeSearchParams();
		params.setId(newEmployee.getId());
		allEmployees = employeeRepository.search(params);
		Assert.assertEquals("Search should match by id", 1, allEmployees.size());
		Assert.assertEquals(newEmployee.getId(), allEmployees.get(0).getId());
	}
	
	@Test
	public void testSearchPrevious() {
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Brian Griffin");
		newEmployee.setPhone("09123-12312312");
		newEmployee.setOffice(this.office);
		newEmployee.setWorkingSince(new Date());
		employeeRepository.persist(newEmployee);
		Employee previous = employeeRepository.searchPrevious("bri");
		Assert.assertNull("Search should match exact email", previous);
		previous = employeeRepository.searchPrevious("brian@griffin.com");
		Assert.assertNotNull("Search should match exact email", previous);
		Assert.assertEquals(newEmployee.getEmail(), previous.getEmail());
		Assert.assertEquals(newEmployee.getEmail(), previous.getEmail());
		Assert.assertEquals(newEmployee.getName(), previous.getName());
		Assert.assertEquals(newEmployee.getPhone(), previous.getPhone());
		Assert.assertEquals(newEmployee.getOffice().getId(), previous.getOffice().getId());
	}
	
	@Test
	public void testAttemptInjection() {
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Brian Griffin");
		newEmployee.setPhone("9080213123-1321");
		newEmployee.setOffice(this.office);
		newEmployee.setWorkingSince(new Date());
		employeeRepository.persist(newEmployee);
		EmployeeSearchParams params = new EmployeeSearchParams();
		//will try to break the query thus triggering an exception
		params.setEmail("' FROM");
		List<Employee> search = employeeRepository.search(params);
		Assert.assertEquals("No match should be found", 0, search.size());
	}
	
	@Test
	public void testEscapeChar() {
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Br!an Griffin");
		newEmployee.setPhone("582-062012");
		newEmployee.setOffice(this.office);
		newEmployee.setWorkingSince(new Date());
		employeeRepository.persist(newEmployee);
		EmployeeSearchParams params = new EmployeeSearchParams();
		params.setName("Br!a");
		List<Employee> search = employeeRepository.search(params);
		Assert.assertEquals("Escape char should be escaped", 1, search.size());
		Assert.assertEquals(newEmployee.getEmail(), search.get(0).getEmail());
		Assert.assertEquals(newEmployee.getEmail(), search.get(0).getEmail());
		Assert.assertEquals(newEmployee.getName(), search.get(0).getName());
		Assert.assertEquals(newEmployee.getPhone(), search.get(0).getPhone());
		Assert.assertEquals(newEmployee.getWorkingSince(), search.get(0).getWorkingSince());
		Assert.assertEquals(newEmployee.getOffice().getId(), search.get(0).getOffice().getId());
		params = new EmployeeSearchParams();
		params.setName("Br%");
		search = employeeRepository.search(params);
		Assert.assertEquals("No match should be found", 0, search.size());
	}
	
	@Test(expected=javax.persistence.PersistenceException.class)
	public void testDuplicatedEmail(){
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Brian Griffin");
		newEmployee.setPhone("1222-0987654");
		newEmployee.setOffice(this.office);
		employeeRepository.persist(newEmployee);
		Employee otherEmployee = new Employee();
		otherEmployee.setCreation(new DateTime());
		otherEmployee.setEmail("brian@griffin.com");
		otherEmployee.setName("Evil Twin Brian Griffin");
		otherEmployee.setPhone("0987654-1222");
		otherEmployee.setOffice(this.office);
		employeeRepository.persist(otherEmployee);
	}
	
	@Test(expected=javax.persistence.PersistenceException.class)
	public void testEmailTooLong(){
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		String longEmail = RandomGenerator.randomString(258);
		Assert.assertTrue("generated email should be greated than 256", 256 < longEmail.length());
		newEmployee.setEmail(longEmail);
		newEmployee.setName("Brian Griffin");
		newEmployee.setPhone("1222-0987654");
		newEmployee.setOffice(this.office);
		employeeRepository.persist(newEmployee);
	}
	
	@Test(expected=javax.persistence.PersistenceException.class)
	public void testNameTooLong(){
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		String longName = RandomGenerator.randomString(82);
		Assert.assertTrue("generated email should be greated than 80", 80 < longName.length());
		newEmployee.setName(longName);
		newEmployee.setPhone("1222-0987654");
		newEmployee.setOffice(this.office);
		employeeRepository.persist(newEmployee);
	}
	
	@Test(expected=javax.persistence.PersistenceException.class)
	public void testPhoneTooLong(){
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Brian Griffin");
		String longPhone = RandomGenerator.randomString(52);
		Assert.assertTrue("generated email should be greated than 50", 50 < longPhone.length());
		newEmployee.setPhone(longPhone);
		newEmployee.setOffice(this.office);
		newEmployee.setWorkingSince(new Date());
		employeeRepository.persist(newEmployee);
	}
	
	@Test(expected=javax.persistence.PersistenceException.class)
	public void testNoOffice(){
		Employee newEmployee = new Employee();
		newEmployee.setCreation(new DateTime());
		newEmployee.setEmail("brian@griffin.com");
		newEmployee.setName("Brian Griffin");
		newEmployee.setPhone("027-92612");
		newEmployee.setWorkingSince(new Date());
		employeeRepository.persist(newEmployee);
	}
	
	@Test
	public void testOrder(){
		DateTime dateTime = new DateTime();
		for(int i = 0; i < 9; i++){
			Employee newEmployee = new Employee();
			newEmployee.setCreation(new DateTime());
			newEmployee.setEmail("brian"+i+"@griffin.com");
			newEmployee.setName(Integer.valueOf(9 - i).toString());
			newEmployee.setOffice(this.office);
			Date ws = dateTime.minusWeeks(9 - i).toDate();
			newEmployee.setWorkingSince(ws);
			employeeRepository.persist(newEmployee);
		}
		EmployeeSearchParams searchParams = new EmployeeSearchParams();
		searchParams.setOrder(EmployeeOrder.DescWorkingSince);
		List<Employee> orderedEmployees = employeeRepository.search(searchParams);
		Assert.assertEquals("Search should contain all results", 9, orderedEmployees.size());
		int value = 1;
		for(Employee orderedEmployee : orderedEmployees){
			Assert.assertEquals("Employee should be ordered", Integer.valueOf(value).toString(), orderedEmployee.getName());
			value++;
		}
	}
	
	@Test
	public void testRetrieveAllEmployeesEmpty() {
		EmployeeSearchParams params = new EmployeeSearchParams();
		params.setFetchOffice(true);
		List<Employee> allEmployees = employeeRepository.search(params);
		Assert.assertEquals("If no EmployeeSearchParamsemployees, the query should return an empty list", 0, allEmployees.size());
	}
}
